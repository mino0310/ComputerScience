#include <stdio.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>

int main(void)
{
    int n, rank = 1, max_index, max_score = 101;
    scanf("%d", &n);
    std::vector<int> score(n);
    std::vector<int> check(n);

    for (int i = 0; i < n; i++) {
        scanf("%d", &score[i]);
    }

    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (score[i] < score[j]) {
                check[j]++;
            }
            else if (score[i] > score[j]) {
                check[i]++;
            }
            else {
                check[i]++;
                check[j]++;
            }
        }
    }
    for (int i = 0; i < n; i++)
    {
        printf("%d ", check[i]);
    }

    return 0;
}



/*
1. 등수를 구해야 한다. 
2. 정렬을 해버리면 인덱스가 사라져버리니까 답을 도출해내기가 어려움.
3. 실마리를 찾자.
우선 입력받은 배열이 있고 순위 체크 배열을 따로 두는 건 어떤가
그래서 최댓값의 인덱스를 그대로 따와서 순위체크 인덱스로 보는 것이지. 

동일한 점수일 때는 계속 같은 석차를 매긴다. 그러나 ++ 해주는 듯. 그래야지 
동점 석차 다음에 나오는 이의 석차를 제대로 매겨줄 수있으니까

입력 배열과 체크 배열을 이어주는 것은 인덱스니까 인덱스로 랭크를 측정하자
그리고 1등을 구하고 그것의 랭크를 올려주고 
그다음 1등으로 측정된 값을 0으로 만들어주는 게 낫지 않나?

전역변수로 배열을 선언해서 그 배열에 입력 받음
그 배열을 탐색해서 최댓값의 인덱스를 반환함. 그리고 최댓값을 0으로 만듦
만들면 안됨. 그러면 같을 경우을 비교할 수 없음 -- 기각

숫자가 들어옴 -> 가장 큰 숫자면 그 숫자에 석차를 부여 -> 그 다음 숫자에
석차를 부여 -> 반복 (최대점수보다 낮고 그 숫자들주에서 가장 큰 걸
찾으면 되지 않나)
우선 최고 점수 상한이 100점이니까 초기 최고점수를 101 점으로 설정해두고
입력배열에서 101점보다 낮고, 가장 큰 숫자를 찾는 것이지
그러면 그 숫자의 인덱스를 가지고 출력 배열의 랭크를 구하는 것이지.
그다음 랭크를 ++ 해주면 되지. 그런식으로 모든 출력 배열을 구하면 되지 않나
도저히 안됨. 

저 점수들이 토너먼트를 한다고 생각해보면 어떨까
모든 숫자들이 서로 붙는데 이길 수록 승점이 올라가는 거지.
그래서 승점대로 석차를 매겨주면 되지 않을까.
이 방식대로 하니까 승점은 구할 수 있다. 이제 이 승점을 석차로 바꿔야지
아니 그냥 처음 주어진 값이랑 사실 똑같음. 다시 처음부터.



*/