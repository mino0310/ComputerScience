#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <vector>

int main(void)
{
    int n, k, i, l = 1, cnt = 0, cut = 0, pos = 1, bp = 0;

    scanf("%d %d", &n, &k);
    std::vector<int> prince(n + 1);

    while (1) {
        if (prince[pos] == 0) {
            cnt++;
        }
        if (cnt == k) {
            cnt = 0;
            prince[pos] = 1;
            bp++;
        }
        if (bp == n - 1) break ;
        pos++;
        if (pos > n) pos = 1;
    }
    for (i = 1; i <= n; i++) {
        if (prince[i] == 0) {
            printf("%d\n", i);
            break ;
        }
    }
    return 0;
}
/*
입력 8 3 
출력 7

이 문제의 핵심은 뭔가
문제에서 말하는 것을 쪼개보자.
둥글게 앉아 있고 (둥글게 자료를 저장해야 함.)
특정 숫자가 되어버리면 해당 공간에서 삭제가 된다. 
그 다음부터 다시 반복 (언제까지? 남은 숫자가 하나일 때까지)

왕자가 동그랗게 모여 앉아 있다.  각각의 번호가 있다.
마지막 왕자 다음이 첫번째 왕자가 되게 하면 된다. 
여러 방법이 있지만 배열에 넣고 배열의 크기를 넘어가게 되면 강제로 첫번째를 가리키게 하면 된다. 

논리는 간단하다 왕자를 계속 지명해가면 된다. 
지명 시 특정 조건을 걸어서 조건에 해당하면 카운트 하면 된다. 주어지는 값을 조건에 걸면 된다.
예를 들어 3번째 외치는 왕자가 나가야 하니까, 이를 저장해둘 변수가 필요하다. 숫자 외치는 왕자를 가리키는 변수와는 따로 변수를 생성해두어야 한다.
이 변수가 3이 되는 순간 해당 인덱스의 값은 비정상 값으로 처리해주면 된다. 

모든 반복이 끝날 족너을 설정해줘야 한다. 이는 배열에 한 명의 왕자가 남았을 때다. 종료를 선언하는 방식은 여러가지가 있을 것인데, 배열을 순회하면서 
남아있는 왕자가 1명인 것을 확인해도 되고 호출되지 않은 왕자만 특별한 값을 같게 해도 된다. 

이런 식으로 구성한 다음 남은 왕자의 인덱스를 출력하면 된다. 



*/