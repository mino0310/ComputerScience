#include <stdio.h>
#include <iostream>
#include <vector>
#include <algorithm>

int main(void)
{
	int n;
	scanf("%d", &n);
	std::vector<int> a(n), b(n);
	for (int i = 0; i < n; i++){
		scanf("%d", &a[i]);
		b[i] = 1;
	}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (a[i] < a[j]) b[i]++;
		}
	}
	for (int i = 0; i < n; i++) {
		printf("%d ", b[i]);
	}
	return 0;
}

// 1. 중요한 것은 석차를 구분하는 것이다.
// 2. 구분은 어떤 기준으로 할 것인가?
// 3. 나보다 크면 나의 석차는 낮아지는 것이다. 나랑 같으면 같은 거고 내가 높으면 내 석차가 높아짐.
// 4. 감산 연산 보다는 증가 연산이 쉽기 때문에 이를 사용한다.
// 5. 낮아진다는 것을 반대로 숫자가 증가하는 것으로 표현하자. 
// 6. 그러니까 내가 상 대보다 낮으면 내가 갖고 있는 석차는++ 되는 것이지. 이런 식이면 
// 나중엔 정확히 내 석차를 표현해낼 수 있을 것임.
// 7. 그러니까 하나씩 하나씩 순회하면서 다른 모든 값들과 비교하면서 내 석차를 만들어가면 됨.
// 8. 기본적으로 모든 이들이ㅡ 석차를 1로 부여한다음 비교해서 석차를 1씩 늘려나가면 됨
// 이렇게 모든 값들을 비교해야 해서 브루트 포스라 하는 구나 이제 알겠음

