#include <stdio.h>
#include <iostream>
#include <vector>
#include <algorithm>
<<<<<<< HEAD
#include <string.h>

int main(void)
{
    int n, rank = 1, max_index, max_score = 101;
    scanf("%d", &n);
    std::vector<int> score(n);
    std::vector<int> check(n);

    for (int i = 0; i < n; i++) {
        scanf("%d", &score[i]);
    }

    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (score[i] < score[j]) {
                check[j]++;
            }
            else if (score[i] > score[j]) {
                check[i]++;
            }
            else {
                check[i]++;
                check[j]++;
            }
        }
    }
    for (int i = 0; i < n; i++)
    {
        printf("%d ", check[i]);
    }

    return 0;
}



/*
1. 등수를 구해야 한다. 
2. 정렬을 해버리면 인덱스가 사라져버리니까 답을 도출해내기가 어려움.
3. 실마리를 찾자.
우선 입력받은 배열이 있고 순위 체크 배열을 따로 두는 건 어떤가
그래서 최댓값의 인덱스를 그대로 따와서 순위체크 인덱스로 보는 것이지. 

동일한 점수일 때는 계속 같은 석차를 매긴다. 그러나 ++ 해주는 듯. 그래야지 
동점 석차 다음에 나오는 이의 석차를 제대로 매겨줄 수있으니까

입력 배열과 체크 배열을 이어주는 것은 인덱스니까 인덱스로 랭크를 측정하자
그리고 1등을 구하고 그것의 랭크를 올려주고 
그다음 1등으로 측정된 값을 0으로 만들어주는 게 낫지 않나?

전역변수로 배열을 선언해서 그 배열에 입력 받음
그 배열을 탐색해서 최댓값의 인덱스를 반환함. 그리고 최댓값을 0으로 만듦
만들면 안됨. 그러면 같을 경우을 비교할 수 없음 -- 기각

숫자가 들어옴 -> 가장 큰 숫자면 그 숫자에 석차를 부여 -> 그 다음 숫자에
석차를 부여 -> 반복 (최대점수보다 낮고 그 숫자들주에서 가장 큰 걸
찾으면 되지 않나)
우선 최고 점수 상한이 100점이니까 초기 최고점수를 101 점으로 설정해두고
입력배열에서 101점보다 낮고, 가장 큰 숫자를 찾는 것이지
그러면 그 숫자의 인덱스를 가지고 출력 배열의 랭크를 구하는 것이지.
그다음 랭크를 ++ 해주면 되지. 그런식으로 모든 출력 배열을 구하면 되지 않나
도저히 안됨. 

저 점수들이 토너먼트를 한다고 생각해보면 어떨까
모든 숫자들이 서로 붙는데 이길 수록 승점이 올라가는 거지.
그래서 승점대로 석차를 매겨주면 되지 않을까.
이 방식대로 하니까 승점은 구할 수 있다. 이제 이 승점을 석차로 바꿔야지
아니 그냥 처음 주어진 값이랑 사실 똑같음. 다시 처음부터.



*/
=======

int main(void)
{
	int n;
	scanf("%d", &n);
	std::vector<int> a(n), b(n);
	for (int i = 0; i < n; i++){
		scanf("%d", &a[i]);
		b[i] = 1;
	}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (a[i] < a[j]) b[i]++;
		}
	}
	for (int i = 0; i < n; i++) {
		printf("%d ", b[i]);
	}
	return 0;
}

// 1. 중요한 것은 석차를 구분하는 것이다.
// 2. 구분은 어떤 기준으로 할 것인가?
// 3. 나보다 크면 나의 석차는 낮아지는 것이다. 나랑 같으면 같은 거고 내가 높으면 내 석차가 높아짐.
// 4. 감산 연산 보다는 증가 연산이 쉽기 때문에 이를 사용한다.
// 5. 낮아진다는 것을 반대로 숫자가 증가하는 것으로 표현하자. 
// 6. 그러니까 내가 상 대보다 낮으면 내가 갖고 있는 석차는++ 되는 것이지. 이런 식이면 
// 나중엔 정확히 내 석차를 표현해낼 수 있을 것임.
// 7. 그러니까 하나씩 하나씩 순회하면서 다른 모든 값들과 비교하면서 내 석차를 만들어가면 됨.
// 8. 기본적으로 모든 이들이ㅡ 석차를 1로 부여한다음 비교해서 석차를 1씩 늘려나가면 됨
// 이렇게 모든 값들을 비교해야 해서 브루트 포스라 하는 구나 이제 알겠음

>>>>>>> 8ef0a78f7c5ed14a2d0fe5c54616c2cf6b386426
